#!/usr/bin/python3
#
# eos-dropbox-app: launcher script to launch Dropbox
#
# Copyright (C) 2017 Endless Mobile, Inc.
# Authors:
#  Mario Sanchez Prada <mario@endlessm.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import argparse
import glob
import json
import logging
import os
import subprocess
import sys

from gi.repository import Gio
from gi.repository import GLib


DROPBOX_CONFIG = '~/.dropbox/info.json'
DROPBOX_LAUNCHER  = '/app/extra/.dropbox-dist/dropboxd'
DROPBOX_DEFAULT_DIR  = '~/Dropbox'


def get_default_dropbox_directory():
    default_dir = os.path.expanduser(DROPBOX_DEFAULT_DIR)

    if os.path.isdir(default_dir):
        return default_dir

    # No 'Dropbox' directory found, our last attempt will be to look for a Dropbox
    # team folder, used in 'business' accounts (e.g. 'Dropbox (Endless Team)')
    team_dir = glob.glob(default_dir + ' (*)')
    if team_dir:
        return team_dir[0]

    # If no Dropbox folder found, that means that the user has not
    # configured Dropbox yet, so there's not much we can do now
    return None


def get_dropbox_directory():
    dropbox_dir = None
    config_path = os.path.expanduser(DROPBOX_CONFIG)

    logging.info("Looking for Dropbox configuration...")
    if not os.path.exists(config_path):
        logging.info("Dropbox configuration not found")
        return None

    with open(config_path, 'r') as config:
        logging.info("Found Dropbox configuration at {}".format(config_path))

        path = None
        account_type = None

        data = config.read()
        try:
            json_data = json.loads(data)
        except ValueError as e:
            logging.warning("Error loading JSON data from {}: {}".format(DROPBOX_CONFIG, str(e)))

        # Search for valid user configuration (containing 'path')
        # and for the type of account (for logging purposes)
        for type_name in json_data:
            if 'path' in json_data[type_name]:
                path = json_data[type_name]['path']
                account_type = type_name
                break

        if path:
            try:
                dropbox_dir = os.path.expanduser(path)
                logging.info("Found configured Dropbox directory at {} ({} account)"
                             .format(dropbox_dir, account_type))
            except KeyError:
                logging.warning("Could not find Dropbox directory in user's configuration")
        else:
            logging.warning("Could not find user's configuration in Dropbox's configuration file")

    if not dropbox_dir:
        logging.warning("Could not find a valid Dropbox directory in the configuration. Falling back to defaults...")
        dropbox_dir = get_default_dropbox_directory()

    return dropbox_dir


class DropboxLauncher():

    def __init__(self):
        self._mainloop = GLib.MainLoop()
        self._already_running = False

    def run(self):
        Gio.bus_own_name(Gio.BusType.SESSION,
                         'com.dropbox.Client',
                         Gio.BusNameOwnerFlags.NONE,
                         None, # Bus Acquired callback
                         self._name_acquired,
                         self._name_lost)
        self._mainloop.run()

    def _name_acquired(self, *args):
        logging.info("No instance of dropbox already running")
        self._launch_dropbox_daemon()
        self._open_dropbox_directory()

    def _name_lost(self, *args):
        logging.info("Another instance of dropbox is already running")
        self._already_running = True
        self._open_dropbox_directory()

    def _exitOnError(self, message):
        logging.error(message)
        self._mainloop.quit()
        sys.exit(1)

    def _open_dropbox_directory(self):
        directory = get_dropbox_directory()
        logging.info("Attempting to open Dropbox directory at {}...".format(directory))

        if not directory:
            logging.warning("User has not configured Dropbox yet")
            return
        elif not os.path.isdir(directory):
            self._exitOnError("{} is not a directory!".format(directory))

        uri = 'file://{}'.format(os.path.expanduser(directory))

        try:
            bus = Gio.bus_get_sync(Gio.BusType.SESSION, None)
            proxy = Gio.DBusProxy.new_sync(bus, Gio.DBusProxyFlags.NONE,
                                           None,
                                           'org.freedesktop.portal.Desktop',
                                           '/org/freedesktop/portal/desktop',
                                           'org.freedesktop.portal.OpenURI',
                                           None)

            logging.info("Opening Dropbox directory at {}...".format(uri))
            handle = proxy.OpenURI('(ssa{sv})',
                                   '',                          # Parent window ID
                                   uri,                         # URI
                                   GLib.Variant('a{sv}', None)) # Options

            # The OpenURI method returns a handle to a 'request object', which stays
            # alive for the duration of the user interaction related to the method call,
            # so we connect to its Response signal to know when it's all over.
            bus.signal_subscribe('org.freedesktop.portal.Desktop',
                                 'org.freedesktop.portal.Request',
                                 'Response',
                                 handle,
                                 None,
                                 Gio.DBusSignalFlags.NO_MATCH_RULE,
                                 self._responseReceived)

        except GLib.Error as e:
            self._exitOnError("Could not launch the OpenURI portal for {}: {}".format(uri, e.message))

    def _responseReceived(self, connection, sender, path, interface, signal, params):
        # Format string for the Response signal is 'ua{sv}', but we are
        # only interested in the first parameter here (response code).
        #
        # Response code values:
        #  0: Success
        #  1: User cancelled action (e.g. Canceled the App Chooser dialog).
        #  2: Error
        (response_code, results) = params.unpack()
        if response_code == 0:
            logging.info("OpenURI portal: success!")
        elif response_code == 1:
            logging.info("OpenURI portal: cancelled by the user")
        elif response_code == 2:
            logging.warning("OpenURI portal: An error happened")

        if self._already_running:
            # Dropbox launcher already running as a different process,
            # so we can quit here after having handled the URI request
            logging.info("Not the main launcher instance. Exiting")
            self._mainloop.quit()

    def _launch_dropbox_daemon(self):
        logging.info("Launching Dropbox's daemon at {}...".format(DROPBOX_LAUNCHER))
        subprocess.Popen([DROPBOX_LAUNCHER])


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--debug', dest='debug', action='store_true')

    parsed_args = parser.parse_args()
    if parsed_args.debug:
        logging.basicConfig(level=logging.INFO)

    DropboxLauncher().run()

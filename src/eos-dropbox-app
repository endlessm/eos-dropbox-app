#!/usr/bin/python3
#
# eos-dropbox-app: launcher script to launch Dropbox
#
# Copyright (C) 2017 Endless Mobile, Inc.
# Authors:
#  Mario Sanchez Prada <mario@endlessm.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import argparse
import glob
import json
import logging
import os
import subprocess
import sys

from gi.repository import Gio
from gi.repository import GLib


DROPBOX_CONFIG = '~/.dropbox/info.json'
DROPBOX_LAUNCHER  = '/app/extra/.dropbox-dist/dropboxd'
DROPBOX_DEFAULT_DIR  = '~/Dropbox'


def get_default_dropbox_directory():
    default_dir = os.path.expanduser(DROPBOX_DEFAULT_DIR)

    if os.path.isdir(default_dir):
        return default_dir

    # No 'Dropbox' directory found, our last attempt will be to look for a Dropbox
    # team folder, used in 'business' accounts (e.g. 'Dropbox (Endless Team)')
    team_dir = glob.glob(default_dir + ' (*)')
    if team_dir:
        return team_dir[0]

    # If no Dropbox folder found, that means that the user has not
    # configured Dropbox yet, so there's not much we can do now
    return None


def get_dropbox_directory():
    dropbox_dir = None
    config_path = os.path.expanduser(DROPBOX_CONFIG)

    logging.info("Looking for Dropbox configuration...")
    if not os.path.exists(config_path):
        logging.info("Dropbox configuration not found")
        return None

    with open(config_path, 'r') as config:
        logging.info("Found Dropbox configuration at {}".format(config_path))

        path = None
        account_type = None

        data = config.read()
        try:
            json_data = json.loads(data)
        except ValueError as e:
            logging.warning("Error loading JSON data from {}: {}".format(DROPBOX_CONFIG, str(e)))

        # Search for valid user configuration (containing 'path')
        # and for the type of account (for logging purposes)
        for type_name in json_data:
            if 'path' in json_data[type_name]:
                path = json_data[type_name]['path']
                account_type = type_name
                break

        if path:
            try:
                dropbox_dir = os.path.expanduser(path)
                logging.info("Found configured Dropbox directory at {} ({} account)"
                             .format(dropbox_dir, account_type))
            except KeyError:
                logging.warning("Could not find Dropbox directory in user's configuration")
        else:
            logging.warning("Could not find user's configuration in Dropbox's configuration file")

    if not dropbox_dir:
        logging.warning("Could not find a valid Dropbox directory in the configuration. Falling back to defaults...")
        dropbox_dir = get_default_dropbox_directory()

    return dropbox_dir


class DropboxLauncher():

    def __init__(self):
        self._mainloop = GLib.MainLoop()
        self._already_running = False
        self._config_monitor = None
        self._dir_monitor = None
        self._bus_owner_id = 0
        self._quit_if_name_lost = False
        self._daemon = None

    def run(self):
        self._try_own_bus_name()
        self._mainloop.run()

    def _try_own_bus_name(self, replace=False):
        if self._bus_owner_id != 0:
            Gio.bus_unown_name(self._bus_owner_id)

        flags = Gio.BusNameOwnerFlags.ALLOW_REPLACEMENT
        if replace:
            flags |= Gio.BusNameOwnerFlags.REPLACE
            self._quit_if_name_lost = True
            logging.info("Trying to own the dropbox dbus name (this time "
                         "replacing existing ones)...")
        else:
            logging.info("Trying to own the dropbox dbus name...")

        self._bus_owner_id = Gio.bus_own_name(Gio.BusType.SESSION,
                                              'com.dropbox.Client',
                                              flags,
                                              None, # Bus Acquired callback
                                              self._name_acquired,
                                              self._name_lost)

    def _name_acquired(self, *args):
        logging.info("No instance of dropbox already running")
        self._quit_if_name_lost = True
        self._launch_dropbox()

    def _name_lost(self, *args):
        if self._quit_if_name_lost:
            logging.info("Lost the DBus name ownership; quitting...")
            self._quit()
            return

        if not get_dropbox_directory():
            logging.info("Another instance of dropbox is already running but no "
                         "Dropbox folder was found; launching the daemon again")
            self._try_own_bus_name(replace=True)
        else:
            logging.info("Another instance of dropbox is already running")
            self._already_running = True
            self._open_dropbox_when_created()

    def _exitOnError(self, message):
        logging.error(message)
        self._quit(1)

    def _quit(self, retcode=0):
        if self._daemon:
            self._daemon.terminate()
        self._mainloop.quit()
        sys.exit(retcode)

    def _open_dropbox_directory(self):
        directory = get_dropbox_directory()
        logging.info("Attempting to open Dropbox directory at {}...".format(directory))

        if not directory:
            logging.warning("User has not configured Dropbox yet")
            return
        elif not os.path.isdir(directory):
            self._exitOnError("{} is not a directory!".format(directory))

        path = os.path.expanduser(directory)
        try:
            # We need to pass an Unix FD to pass to the OpenFile method
            fd = os.open(path, os.O_PATH | os.O_CLOEXEC)
        except FileNotFoundError as e:
            self._exitOnError("Can't find directory at {}: {}".format(path, e.strerror))

        bus = Gio.bus_get_sync(Gio.BusType.SESSION, None)
        proxy = Gio.DBusProxy.new_sync(bus, Gio.DBusProxyFlags.NONE,
                                       None,
                                       'org.freedesktop.portal.Desktop',
                                       '/org/freedesktop/portal/desktop',
                                       'org.freedesktop.portal.OpenURI',
                                       None)
        try:
            logging.info("Opening Dropbox directory at {}...".format(path))
            result, _out_fd_list = proxy.call_with_unix_fd_list_sync('OpenFile',
                                                                     GLib.Variant('(sha{sv})',
                                                                                  ('', 0, None)),
                                                                     Gio.DBusCallFlags.NONE,
                                                                     -1,
                                                                     Gio.UnixFDList.new_from_array([fd]),
                                                                     None)
            handle, = result.unpack()

        except GLib.GError as e:
            if not e.matches(Gio.dbus_error_quark(), Gio.DBusError.UNKNOWN_METHOD):
                logging.info("Could not open directory {}: {}".format(path, e.message))
                raise

            # This is required for compatibility with xdg-desktop-portal < 0.6, for
            # installations that might have updated the DropBox app before the OS.
            logging.info("OpenFile method not available, falling back to OpenURI...")
            handle = proxy.OpenURI('(ssa{sv})',
                                   '',                       # Parent window ID
                                   "file://{}".format(path), # URI
                                   None)                     # Options

        # OpenURI methods returns a handle to a 'request object', which stays
        # alive for the duration of the user interaction related to the method
        # call, so we connect to its Response signal to know when it's all over.
        bus.signal_subscribe('org.freedesktop.portal.Desktop',
                             'org.freedesktop.portal.Request',
                             'Response',
                             handle,
                             None,
                             Gio.DBusSignalFlags.NO_MATCH_RULE,
                             self._responseReceived)

    def _responseReceived(self, connection, sender, path, interface, signal, params):
        # Format string for the Response signal is 'ua{sv}', but we are
        # only interested in the first parameter here (response code).
        #
        # Response code values:
        #  0: Success
        #  1: User cancelled action (e.g. Canceled the App Chooser dialog).
        #  2: Error
        (response_code, results) = params.unpack()
        if response_code == 0:
            logging.info("OpenURI portal: success!")
        elif response_code == 1:
            logging.info("OpenURI portal: cancelled by the user")
        elif response_code == 2:
            logging.warning("OpenURI portal: An error happened")

        if self._already_running:
            # Dropbox launcher already running as a different process,
            # so we can quit here after having handled the URI request
            logging.info("Not the main launcher instance. Exiting")
            self._quit()

    def _launch_dropbox(self):
        self._launch_dropbox_daemon()
        self._setup_config_monitor()

    def _setup_config_monitor(self):
        config = Gio.File.new_for_path(os.path.expanduser(os.path.expanduser(DROPBOX_CONFIG)))
        self._config_monitor = config.monitor(Gio.FileMonitorFlags.NONE)
        self._config_monitor.connect('changed', self._on_config_changed)

    def _launch_dropbox_daemon(self):
        logging.info("Launching Dropbox's daemon at {}...".format(DROPBOX_LAUNCHER))
        self._daemon = subprocess.Popen([DROPBOX_LAUNCHER])

    def _on_config_changed(self, monitor, file_obj, other_file, event_type):
        logging.info("Config file monitor {}: {}".format(file_obj.get_path(), event_type))
        if event_type != Gio.FileMonitorEvent.CHANGES_DONE_HINT:
            if event_type == Gio.FileMonitorEvent.DELETED and self._dir_monitor:
                self._dir_monitor.cancel()
            return
        self._config_monitor.cancel()
        if os.path.exists(file_obj.get_path()):
            logging.info("Configuration for Dropbox created; opening folder when created...")
            self._open_dropbox_when_created()

    def _open_dropbox_when_created(self):
        dropbox_dir = get_dropbox_directory()
        if dropbox_dir is None:
            logging.warning("No Dropbox folder configured yet. Cannot open or monitor it!")
            return
        if os.path.exists(dropbox_dir):
            self._open_dropbox_directory()
            return
        logging.info("Setting up monitor for folder {}...".format(dropbox_dir))
        dir_obj = Gio.File.new_for_path(dropbox_dir)
        self._dir_monitor = dir_obj.monitor(Gio.FileMonitorFlags.NONE)
        self._dir_monitor.connect('changed', self._on_dir_changed)

    def _on_dir_changed(self, monitor, file_obj, other_file, event_type):
        logging.info("Dropbox dir monitor {}: {}".format(file_obj.get_path(), event_type))
        if event_type != Gio.FileMonitorEvent.CREATED:
            return
        logging.info("Dropbox folder created; opening now...")
        self._open_dropbox_directory()
        self._dir_monitor.cancel()

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--debug', dest='debug', action='store_true')

    parsed_args = parser.parse_args()
    if parsed_args.debug:
        logging.basicConfig(level=logging.INFO)

    DropboxLauncher().run()
